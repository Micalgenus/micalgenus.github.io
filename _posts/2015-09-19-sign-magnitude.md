---
layout: post
title: sign-magnitude
categories: [Computer Structure]
comments: true
---

sign-magnitude는 전체 bit중에 **최상위 bit**의 값을 이용하여 부호를 판별하는 방법이다.

이 방법을 이용하면 기존에 양의 정수밖에 표현할 수 밖에 없던 값을 **음수**도 표현할 수 있도록 도와준다.

4bit의 환경을 예를 들겠다.

4bit로된 3과 -3이라는 값이 있다. 이는 bit로 표현하면

```
 3: 0 0 1 1
-3: 1 0 1 1
```

이 둘의 차이를 보면 맨앞인 최상위 bit만 다르다는 점이다.

이 방식에는 단점이 존재한다. 가장 큰 문제점은 음수가 작아지면(절대값은 커지면) bit값은 커지게 되는데, 이를 예를 들어 알아보자.

```
-0: 1 0 0 0
-1: 1 0 0 1
-2: 1 0 1 0
-3: 1 0 1 1
-4: 1 1 0 0
-5: 1 1 0 1
-6: 1 1 1 0
-7: 1 1 1 1
```

`음수`의 값은 점점 작아지는데, bit로 보게되면 값은 **점점 커지게** 된다. 이와 반대로 양수의 경우를 보자.

```
0: 0 0 0 0
1: 0 0 0 1
2: 0 0 1 0
3: 0 0 1 1
4: 0 1 0 0
5: 0 1 0 1
6: 0 1 1 0
7: 0 1 1 1
```

`양수`는 값이 커지면 bit로 보아도 **값이 커지게** 된다. 

가장 큰 문제점은 양수와 음수의 계산에서 발생한다.

3과 -3을 더하게 될 경우 0이 나와야 하는데, 실제로 계산을 해보게 되면 그러한 결과가 나오지 않게 된다.

```
   3 |   0 0 1 1
+ -3 | + 1 0 1 1
-----|----------
  -6 |   1 1 1 0
```

3과 -3을 더했는데 실제 비트를 비교해 보면 -6이 나오게 된다.

이 때문에 음수와 양수의 계산에서 새롭게 정의를 해주어야 한다.

두번째 문제점이 되는 이유는, 비교연산과 같은 부분에서 발생한다. 비교연산을 하게되면, 양수끼리 비교를 하게될 경우 bit로 보아서 큰값이 큰 값이 된다.

하지만, `음수`의 경우 bit가 클 경우 실제 값은 더 작은 경우가 된다. 이 때 비교연산하는 부분을 **따로 정의**를 해주어야 하므로 낭비가 발생한다.

마지막 문제점은 0과 -0이 동시에 존재하는 점이다. bit로는 다른 `0000`과 `1000`이지만 실제 값은 같은 0을 가르키고 있으므로 **낭비**가 생기게 된다.